4. DESENVOLVIMENTO E IMPLEMENTAÇÃO

Este capítulo apresenta o processo de construção da aplicação "Lista de Compras", detalhando a implementação da arquitetura de software, a modelagem da estrutura de dados, o fluxo de navegação do usuário através das telas e as soluções técnicas adotadas para as funcionalidades mais relevantes do sistema.

4.1. Arquitetura da Solução

Conforme antecipado na fundamentação teórica, a aplicação foi construída sobre o padrão de arquitetura Model-View-ViewModel (MVVM), utilizando o framework GetX para sua implementação. A interação entre as camadas foi projetada para garantir um alto nível de desacoplamento e separação de responsabilidades, conforme ilustrado no Diagrama 1.

**[INSERIR DIAGRAMA 1: ARQUITETURA DE CAMADAS DO APLICATIVO]**

O fluxo de dados e eventos ocorre da seguinte forma:

1.  A **View** (telas em Flutter) é responsável exclusivamente pela apresentação da UI. Ela captura as interações do usuário (ex: um toque em um botão) e invoca um comando no **Controller** correspondente.
2.  O **Controller** (atuando como ViewModel) contém a lógica de apresentação e o estado da UI. Ele processa a requisição da View e solicita os dados ou operações necessárias ao **Repository**.
3.  O **Repository** encapsula toda a lógica de acesso à fonte de dados. Ele recebe as chamadas do Controller e as traduz em operações específicas para o **Firebase** (leituras ou escritas no Firestore, por exemplo).
4.  As atualizações de estado no Controller, resultantes das operações, são observadas pela View de forma reativa, que se reconstrói para exibir os dados atualizados ao usuário.

A injeção de dependências, gerenciada pelo sistema de `Bindings` do GetX, garante que as instâncias dos repositórios e outros serviços sejam criadas de forma centralizada e disponibilizadas aos controllers de maneira desacoplada, através do localizador de serviços `Get.find()`.

A seguir, cada uma dessas camadas é detalhada.

### 4.2. Modelagem de Dados do Sistema (Model)

A arquitetura de dados da aplicação é fundamentada em quatro modelos principais, que representam as entidades centrais do sistema: Usuários, Produtos, Listas de Compras e os Itens dentro dessas listas.

#### 4.2.1. `UserModel` (Modelo de Usuário)

O `UserModel` armazena as informações do usuário da aplicação. A estrutura foi projetada para conter dados essenciais de identificação e contato.

*   **Atributos Principais:**
    *   `id`: Identificador único do usuário, geralmente obtido através do serviço de autenticação (Firebase Authentication).
    *   `name`: Nome do usuário.
    *   `email`: Endereço de e-mail, utilizado para login e comunicação.
    *   `phone`: Número de telefone.
    *   `fcmToken`: Um token específico do dispositivo, utilizado pelo Firebase Cloud Messaging (FCM) para o envio de notificações push, como convites para listas compartilhadas.

#### 4.2.2. `ProductModel` (Modelo de Produto)

O `ProductModel` define a estrutura para um item no catálogo global de produtos. Este catálogo permite que produtos comuns sejam pré-cadastrados e reutilizados pelos usuários em suas listas, agilizando o processo de criação.

*   **Atributos Principais:**
    *   `id`: Identificador único do produto no banco de dados.
    *   `name`: Nome do produto (ex: "Leite Integral").
    *   `imageUrl`: URL para uma imagem do produto.
    *   `createdBy`: Identificador do usuário que adicionou o produto ao catálogo.
    *   `status`: Indica a disponibilidade do produto no catálogo (ex: "ativo").

#### 4.2.3. `ShoppingListModel` (Modelo de Lista de Compras)

Este é um dos modelos mais complexos e centrais, representando uma lista de compras. Ele não só contém os dados da lista em si, mas também gerencia o compartilhamento e o estado dela.

*   **Atributos Principais:**
    *   `id`: Identificador único da lista.
    *   `name`: Nome descritivo da lista (ex: "Compras do Mês").
    *   `ownerId`: Identificador do usuário que criou a lista.
    *   `members`: Um mapa que associa identificadores de usuários (`UID`) a suas permissões (ex: 'owner', 'editor'). Este atributo é a base para a funcionalidade de compartilhamento em tempo real.
    *   `category`: Categoria da lista (ex: "Mercado", "Farmácia"), para fins de organização e análise.
    *   `status`: Estado atual da lista (ex: "ativa", "finalizada").
    *   `totalPrice`: Armazena o valor total calculado quando a lista é finalizada, servindo como dado para o histórico de gastos.

#### 4.2.4. `ShoppingItemModel` (Modelo de Item da Lista)

O `ShoppingItemModel` representa um item específico que pertence a uma `ShoppingListModel`. É a menor unidade de uma lista de compras.

*   **Atributos Principais:**
    *   `id`: Identificador único do item dentro da lista.
    *   `listId`: Referência à lista de compras (`ShoppingListModel`) à qual o item pertence.
    *   `name`: Nome do item (ex: "Caixa de Ovos").
    *   `quantity`: Quantidade desejada do item.
    *   `price`: Preço unitário ou total do item (opcional).
    *   `isCompleted`: Campo booleano que indica se o item já foi coletado/comprado, permitindo o acompanhamento do progresso da compra.
    *   `productId`: Campo opcional que vincula o item a um `ProductModel` do catálogo global, permitindo o reaproveitamento de dados do produto.

### 4.3. Camada de Acesso a Dados (Repositórios)

A comunicação entre a lógica de negócios da aplicação e o banco de dados (Cloud Firestore) é abstraída por uma camada de repositórios. Cada repositório é responsável pelo gerenciamento de uma entidade específica do sistema, encapsulando as operações de leitura, escrita, atualização e exclusão de dados (CRUD), além de expor fluxos de dados em tempo real (`Stream`).

#### 4.3.1. `AuthRepository` (Repositório de Autenticação)

Este repositório gerencia todos os aspectos relacionados à autenticação e aos dados do usuário.

*   **Responsabilidades:**
    *   **Autenticação:** Encapsula os métodos do Firebase Authentication para criar um novo usuário (`createUserWithEmailAndPassword`), realizar login (`signInWithEmailAndPassword`), redefinir senha (`sendPasswordResetEmail`) e fazer logout (`signOut`).
    *   **Gerenciamento de Dados no Firestore:** Após a autenticação, ele é responsável por salvar (`createUserInFirestore`) e buscar (`getUserModelFromFirestore`) os dados do perfil do usuário na coleção `users` do Firestore.
    *   **Atualizações Específicas:** Contém lógicas para atualizar o token de notificação (`updateUserFCMToken`) e para buscar um usuário pelo seu e-mail (`getUserByEmail`), funcionalidade essencial para o compartilhamento de listas.

#### 4.3.2. `ProductRepository` (Repositório de Produtos)

Gerencia as operações relacionadas ao catálogo global de produtos.

*   **Responsabilidades:**
    *   **Leitura de Dados:** Fornece um fluxo contínuo (`Stream`) de todos os produtos do catálogo, ordenados por nome (`getProductsStream`), permitindo que a interface do usuário se atualize em tempo real.
    *   **Criação e Modificação:** Contém métodos para adicionar (`addProduct`), atualizar (`updateProduct`) e excluir (`deleteProduct`) produtos do catálogo.
    *   **Upload de Imagem:** Inclui uma função (`uploadImage`) que lida com o upload de imagens de produtos para o Firebase Storage, retornando a URL da imagem para ser armazenada no Firestore.

#### 4.3.3. `ShoppingListRepository` (Repositório de Listas de Compras)

É responsável por gerenciar as listas de compras, que são a entidade principal do aplicativo.

*   **Responsabilidades:**
    *   **Leitura de Listas:** Fornece `Streams` para obter listas ativas (`getShoppingListsStream`) e listas do histórico (`getHistoricalListsStream`) nas quais o usuário atual é um membro. Isso garante que a tela inicial e a de histórico sempre mostrem dados atualizados.
    *   **Operações CRUD:** Permite adicionar (`addList`) e atualizar (`updateList`) uma lista de compras.
    *   **Buscas e Filtros:** Possui uma lógica de consulta avançada (`getFilteredShoppingLists`) para filtrar listas do histórico por um intervalo de datas, funcionalidade utilizada na tela de análise de gastos.

#### 4.3.4. `ShoppingItemRepository` (Repositório de Itens da Lista)

Este repositório gerencia os itens individuais que compõem uma lista de compras. As operações são sempre vinculadas a uma lista específica.

*   **Responsabilidades:**
    *   **Leitura de Itens:** Fornece um `Stream` (`getItemsStream`) que observa e retorna todos os itens de uma determinada lista, ordenados por data de criação.
    *   **Operações CRUD:** Contém métodos para adicionar (`addItem`), atualizar (`updateItem`) e remover (`deleteItem`) itens de uma lista.
    *   **Atualização de Estado:** Possui um método específico (`updateItemCompletion`) para marcar um item como "concluído", uma das interações mais frequentes do usuário durante uma compra.

### 4.4. Camada de Controle (Controllers)

A lógica de negócio e o gerenciamento de estado da aplicação são implementados na camada de controle, utilizando o pacote de gerenciamento de estado **GetX**. Cada `Controller` é responsável por uma área específica da aplicação, orquestrando as interações do usuário, processando dados obtidos dos repositórios e preparando-os para serem exibidos pela camada de visualização (`View`).

#### 4.4.1. `AuthController` (Controlador de Autenticação)

É o ponto central para o gerenciamento de sessão do usuário.

*   **Responsabilidades:**
    *   **Gerenciamento de Estado de Autenticação:** Utiliza um `Stream` do `AuthRepository` para ouvir mudanças no estado de autenticação do usuário em tempo real. Ao detectar uma mudança (login ou logout), redireciona o usuário para a tela apropriada (`HomePage` ou `LoginPage`).
    *   **Processamento de Formulários:** Contém a lógica para validar e processar os formulários de login, cadastro e redefinição de senha, invocando os métodos correspondentes no `AuthRepository`.
    *   **Carregamento de Perfil:** Após o login, é responsável por carregar os dados do perfil do usuário do Firestore e mantê-los disponíveis para outras partes da aplicação.
    *   **Token de Notificação:** Gerencia a obtenção e atualização do token do Firebase Cloud Messaging (FCM) para o usuário logado.

#### 4.4.2. `ShoppingListController` e `ShoppingItemController`

Esta dupla de controladores gerencia a principal funcionalidade do aplicativo: a criação e manipulação de listas de compras e seus itens.

*   **`ShoppingListController`:**
    *   **Gerenciamento de Listas Ativas:** Mantém e exibe a lista de compras ativas do usuário.
    *   **Ciclo de Vida da Lista:** Implementa a lógica para criar, editar, arquivar e finalizar listas. Ao finalizar uma lista, ele calcula o preço total dos itens e a move para o histórico.
    *   **Agendamento de Notificações:** Contém a lógica complexa para agendar, atualizar e cancelar notificações locais relacionadas às datas de compra agendadas.

*   **`ShoppingItemController`:**
    *   **Gerenciamento de Itens:** Lida com a adição, edição, exclusão e marcação de itens como "concluídos" dentro de uma lista específica.
    *   **Vinculação de Dados:** Associa-se a uma lista de compras (`listId`) para exibir e gerenciar apenas os itens pertencentes a ela.

#### 4.4.3. `ProductController` (Controlador do Catálogo de Produtos)

Responsável por toda a interação com o catálogo global de produtos.

*   **Responsabilidades:**
    *   **Visualização do Catálogo:** Disponibiliza a lista de produtos do catálogo para a interface do usuário.
    *   **Operações CRUD:** Implementa a lógica para adicionar um novo produto (incluindo o upload da imagem), editar e excluir itens do catálogo.

#### 4.4.4. `MembersController` (Controlador de Membros)

Gerencia a funcionalidade de compartilhamento de listas.

*   **Responsabilidades:**
    *   **Convite de Usuários:** Contém a lógica para convidar um novo usuário para uma lista através do seu e-mail. Ele busca o usuário no banco de dados e o adiciona ao mapa de `members` da lista.
    *   **Visualização de Membros:** Busca e exibe os detalhes dos usuários que são membros de uma determinada lista.

#### 4.4.5. `HistoryController` e `SpendingAnalysisController`

Estes controladores são focados na análise de dados históricos.

*   **`HistoryController`:** Simplesmente busca e exibe o fluxo de listas que foram marcadas como "finalizada" or "arquivada".
*   **`SpendingAnalysisController`:**
    *   **Filtragem de Dados:** Permite que o usuário filtre as compras históricas por um intervalo de datas.
    *   **Cálculo de Métricas:** Calcula o gasto total no período selecionado.
    *   **Visualização de Dados:** Processa os dados para gerar um gráfico de pizza (`PieChart`) que mostra a distribuição de gastos por categoria, oferecendo ao usuário insights sobre seus hábitos de compra.

#### 4.4.6. `SuggestionController` (Controlador de Sugestões)

Implementa uma funcionalidade de inteligência para o usuário.

*   **Responsabilidades:**
    *   **Análise de Histórico:** Analisa o histórico de compras do usuário para identificar os produtos comprados com mais frequência.
    *   **Geração de Sugestões:** Com base na frequência, ele busca os produtos correspondentes no catálogo e os exibe como uma lista de sugestões, facilitando a adição de itens recorrentes a uma nova lista.

### 4.5. Camada de Apresentação (View)

A camada de apresentação é responsável por construir a interface do usuário (UI). Ela é composta por um conjunto de **telas (páginas)**, que representam os diferentes contextos da aplicação, e **widgets**, que são componentes reutilizáveis para construir essas telas de forma consistente e eficiente. A `View` utiliza os dados e a lógica dos `Controllers` para se manter atualizada e para responder às interações do usuário.

#### 4.5.1. Telas Principais (`lib/view/`)

*   **`login_page.dart`:** A porta de entrada da aplicação. Apresenta um formulário para login e registro, alternando entre as duas visualizações. Utiliza o `AuthController` para gerenciar a autenticação.
*   **`splash_page.dart`:** Uma tela de carregamento inicial que é exibida enquanto o aplicativo verifica o estado de autenticação do usuário para decidir se o direciona para a tela de login ou para a tela principal.
*   **`home_page.dart`:** A tela principal da aplicação. Exibe as listas de compras ativas do usuário. A partir daqui, o usuário pode criar novas listas e navegar para outras seções do aplicativo através de um menu lateral (`Drawer`).
*   **`list_details_page.dart`:** Exibe os itens de uma lista de compras específica. É a tela onde o usuário passa a maior parte do tempo, adicionando, editando e marcando itens como concluídos.
*   **`members_page.dart`:** Tela dedicada ao gerenciamento de membros de uma lista compartilhada. Permite visualizar os membros atuais e convidar novos participantes.
*   **`product_catalog_page.dart`:** Apresenta o catálogo global de produtos, permitindo que os usuários visualizem, adicionem, editem e removam produtos do catálogo.
*   **`history_page.dart`:** Exibe o histórico de listas de compras finalizadas e arquivadas, permitindo ao usuário consultar compras passadas.
*   **`spending_analysis_page.dart`:** A tela de análise de gastos. Apresenta um seletor de datas, o valor total gasto no período e um gráfico de pizza com a distribuição de gastos por categoria.

#### 4.5.2. Widgets Reutilizáveis (`lib/view/widgets/`)

A aplicação faz uso extensivo de widgets customizados para promover a reutilização de código e a consistência visual.

*   **Diálogos (`..._dialog.dart`):** Widgets como `create_list_dialog.dart`, `add_product_dialog.dart`, e `edit_list_dialog.dart` encapsulam formulários em janelas de diálogo para a criação e edição de dados, proporcionando uma experiência de usuário fluida sem a necessidade de navegar para uma nova tela.
*   **Componentes de UI Genéricos:**
    *   `custom_app_bar.dart`: Uma barra de aplicativo padrão para manter a consistência entre as telas.
    *   `custom_drawer.dart`: O menu de navegação lateral, que dá acesso a todas as seções principais do aplicativo.
    *   `auth_text_form_field.dart`: Um campo de texto customizado para os formulários de autenticação, com validação e controle de visibilidade de senha.
*   **Widgets de Exibição de Dados:**
    *   `pie_chart_card.dart` e `total_spending_card.dart`: Widgets especializados para a tela de análise de gastos, que exibem o gráfico e o valor total, respectivamente.
    *   `history_list_tile.dart`: Um item de lista customizado para exibir as informações de uma compra no histórico.
    *   **Cards (`lib/view/widgets/cards/`):** Componentes como `product_card.dart` e `square_card.dart` são usados para exibir informações de forma visualmente atraente em grades ou listas.
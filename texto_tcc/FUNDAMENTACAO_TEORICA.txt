2. FUNDAMENTAÇÃO TEÓRICA

Neste capítulo, são apresentados os conceitos, tecnologias e padrões de arquitetura que formam a base para o desenvolvimento do aplicativo "Lista de Compras". A escolha de cada componente foi estratégica para atender aos requisitos de multiplataforma, escalabilidade e manutenibilidade do projeto.

2.1. Flutter e o Desenvolvimento Multiplataforma

Flutter é um framework de código aberto, mantido pela Google, para a criação de interfaces de usuário (UI) compiladas nativamente para aplicações móveis, web e desktop a partir de uma única base de código. Sua arquitetura é fundamentada na linguagem de programação Dart, também desenvolvida pela Google, que é otimizada para a construção de UIs e compilada para código de máquina ARM ou x86, além de JavaScript para a web. O paradigma central do Flutter é a composição de widgets, onde a interface é construída através da combinação de pequenos componentes reutilizáveis, que o próprio framework fornece em abundância, seguindo as diretrizes de design do Material Design e Cupertino.

A principal vantagem do Flutter, e a razão de sua escolha para este projeto, é a capacidade de entregar uma experiência de usuário consistente e de alta performance em diferentes plataformas (Android, iOS, Web) com um esforço de desenvolvimento significativamente reduzido em comparação com o desenvolvimento nativo para cada plataforma. Isso elimina a necessidade de manter bases de código separadas, otimizando o tempo e os recursos do projeto.

2.2. Firebase: Backend-as-a-Service (BaaS)

Firebase é uma plataforma de desenvolvimento de aplicativos da Google que fornece uma suíte de serviços de back-end (Backend-as-a-Service), permitindo que os desenvolvedores se concentrem na lógica de negócio e na experiência do usuário sem a necessidade de gerenciar a infraestrutura do servidor. Para este projeto, os seguintes serviços foram essenciais:

- **Firebase Authentication:** Oferece um serviço completo e seguro para gerenciar o fluxo de autenticação de usuários. Ele suporta diversos métodos, como e-mail/senha e provedores sociais, e lida com toda a complexidade de armazenamento de credenciais, hashing de senhas e segurança, abstraindo essa responsabilidade do desenvolvedor.

- **Cloud Firestore:** É um banco de dados NoSQL, flexível e escalável, orientado a documentos e com sincronização de dados em tempo real. Foi utilizado como a principal fonte de persistência para todos os dados da aplicação, como listas, produtos e perfis de usuário. Sua natureza NoSQL permite uma modelagem de dados flexível, e sua capacidade de sincronização em tempo real é fundamental para a funcionalidade de compartilhamento de listas.

- **Firebase Storage:** Provê armazenamento seguro e escalável para o upload e download de arquivos gerados pelo usuário, como as imagens dos produtos. Ele desacopla o armazenamento de arquivos binários do banco de dados principal, o que é uma prática recomendada para performance e organização.

2.3. Padrão de Arquitetura MVVM (Model-View-ViewModel)

A arquitetura do projeto foi estruturada com base no padrão de projeto de interface de usuário Model-View-ViewModel (MVVM), que promove uma clara separação de responsabilidades entre a interface e a lógica de negócios.

- **Model:** Representa os dados e a lógica de negócios fundamental. No contexto deste projeto, são classes puras em Dart que definem a estrutura dos dados (ex: `ShoppingListModel`, `UserModel`).

- **View:** É a camada de apresentação (UI), composta por widgets Flutter. Sua única responsabilidade é exibir os dados para o usuário e capturar suas interações (como toques em botões), delegando toda a lógica de negócio para o ViewModel.

- **ViewModel (Controller):** Atua como um intermediário entre o Model e a View. Ele contém a lógica de apresentação e o estado da UI (ex: `isLoading`). Ele expõe os dados do Model para a View de uma forma que a View possa consumir facilmente e provê comandos (funções) que a View pode invocar em resposta às interações do usuário. No contexto do framework GetX, utilizado no projeto, os `Controllers` desempenham o papel de ViewModel.

2.4. Padrão de Repositório (Repository Pattern)

Para desacoplar a lógica de negócios da fonte de dados, foi implementado o Padrão de Repositório. As classes de repositório (ex: `ShoppingListRepository`, `AuthRepository`) encapsulam toda a lógica de acesso aos dados do Firebase. Os `Controllers` (ViewModels) interagem com os repositórios através de uma interface bem definida, sem conhecer os detalhes de implementação do acesso ao banco de dados (se é Firestore, uma API REST, etc.). Essa abstração é crucial para a testabilidade, permitindo a criação de testes unitários com repositórios "mockados" (simulados), e para a manutenibilidade do sistema, pois permite a troca da fonte de dados no futuro com impacto mínimo no restante da aplicação.

2.5. Gerenciamento de Estado com GetX

GetX foi a biblioteca escolhida para atuar como uma solução completa de microframework, provendo não apenas o gerenciamento de estado, mas também injeção de dependências e roteamento. Seu sistema de gerenciamento de estado reativo, que utiliza variáveis observáveis (`.obs`) e widgets reativos (`Obx`), permite que a UI se reconstrua automaticamente apenas nas partes necessárias em resposta a mudanças de estado. Isso resulta em um código mais limpo, performático e com menos verbosidade em comparação com abordagens nativas do Flutter como `StatefulWidget` e `setState()`, simplificando o desenvolvimento e a manutenção da reatividade da interface.

2.6. Revisão de Literatura Acadêmica [A SER DESENVOLVIDO]

[Nesta seção, será incluída uma revisão aprofundada da literatura acadêmica, com citações a autores e trabalhos de referência que discutam os méritos e desafios do desenvolvimento de software multiplataforma, realizem comparações teóricas entre padrões de arquitetura mobile (MVC, MVP, MVVM), e analisem o impacto de plataformas BaaS no ciclo de vida e na agilidade do desenvolvimento de software moderno. Todas as fontes serão devidamente catalogadas e apresentadas na seção de Referências, seguindo a norma ABNT.]